import type { Plugin, UserConfig, ViteDevServer } from 'vite';
import { copyFileSync, mkdirSync, readFileSync, statSync, writeFileSync, unlinkSync } from 'node:fs';
import { join } from 'node:path';

const checkPeerDependencies = async () => {
  const missing: string[] = [];

  try {
    await import('hono');
  } catch {
    missing.push('hono');
  }

  try {
    await import('@hono/node-server');
  } catch {
    missing.push('@hono/node-server');
  }

  // Check @types/node using import.meta.resolve (ESM approach)
  try {
    await import.meta.resolve('@types/node');
  } catch {
    // Fallback: check if Node.js types are available through ambient types
    try {
      // If we can import Node.js built-ins without error, types are likely available
      await import('node:fs');
      await import('node:path');
    } catch {
      missing.push('@types/node');
    }
  }

  return missing;
};

const checkViteVersion = () => {
  try {
    const vitePkg = JSON.parse(readFileSync('node_modules/vite/package.json', 'utf8'));
    const version = vitePkg.version;
    const majorVersion = parseInt(version.split('.')[0], 10);

    if (majorVersion < 6) {
      return { valid: false, currentVersion: version };
    }
    return { valid: true, currentVersion: version };
  } catch {
    return { valid: false, currentVersion: 'unknown' };
  }
};

export interface HonoPluginOptions {
  basePath?: string;
  port?: number;
}

interface HonoAppLike {
  fetch(request: Request): Response | Promise<Response>;
}

const HONO_ENTRY = 'hono/index.ts';
const WRAPPER_FILE = '.hono-server.js';

const fileExists = (path: string) => {
  try {
    return statSync(path).isFile();
  } catch {
    return false;
  }
};

const generateWrapper = (basePath: string, port: number) =>
  `// Auto-generated by vite-plugin-hono
import { Hono } from 'hono';
import { serve } from '@hono/node-server';
import { serveStatic } from '@hono/node-server/serve-static';
import api from './hono/index';

const app = new Hono();
app.route('${basePath}', api);
app.use('*', serveStatic({ root: './frontend' }));
app.get('*', serveStatic({ root: './frontend', path: 'index.html' }));

if (import.meta.url === \`file://\${process.argv[1]}\`) {
  const serverPort = Number(process.env.PORT ?? ${port});
  serve({ fetch: app.fetch, port: serverPort });
  console.log(\`Server running on http://localhost:\${serverPort}\`);
}

export default app;`;

const copyDeployFiles = (targetDir: string, workingDir: string) => {
  mkdirSync(targetDir, { recursive: true });

  for (const file of ['package.json', 'package-lock.json', 'pnpm-lock.yaml', 'yarn.lock', 'bun.lockb']) {
    const path = join(workingDir, file);
    if (!fileExists(path)) continue;

    if (file === 'package.json') {
      const pkg = JSON.parse(readFileSync(path, 'utf8'));
      pkg.scripts = { start: 'node server.js' };
      writeFileSync(join(targetDir, file), JSON.stringify(pkg, null, 2) + '\n', 'utf8');
    } else {
      copyFileSync(path, join(targetDir, file));
    }
  }
};

const loadHonoApp = async (server: ViteDevServer): Promise<HonoAppLike> => {
  const url = `/${HONO_ENTRY}`;
  const moduleNode = await server.moduleGraph.getModuleByUrl(url, true);
  if (moduleNode) await server.moduleGraph.invalidateModule(moduleNode);

  const { default: app } = await server.ssrLoadModule(url);
  if (!app?.fetch) throw new Error(`${HONO_ENTRY} must export a Hono app with fetch()`);
  return app;
};

const readBody = (req: any): Promise<BodyInit | undefined> =>
  new Promise((resolve, reject) => {
    if (req.method === 'GET' || req.method === 'HEAD') return resolve(undefined);
    const chunks: Buffer[] = [];
    req.on('data', (chunk: Buffer) => chunks.push(chunk));
    req.on('end', () => resolve(chunks.length ? Buffer.concat(chunks) as BodyInit : undefined));
    req.on('error', reject);
  });

export default function honoPlugin(options: HonoPluginOptions = {}): Plugin {
  const { basePath = '/api', port = 4173 } = options;
  let workingDir = process.cwd();
  let isBuildCommand = false;

  // Validate Vite version
  const viteCheck = checkViteVersion();
  if (!viteCheck.valid) {
    throw new Error(
      `❌ vite-plugin-hono-api requires Vite 6+. Current version: ${viteCheck.currentVersion}\n` +
      `To upgrade: npm install vite@latest\n` +
      `Or check your package.json for version constraints.`
    );
  }

  return {
    name: 'vite-plugin-hono',

    config: async (_config, env) => {
      workingDir = _config?.root || process.cwd();
      const honoPath = join(workingDir, HONO_ENTRY);
      if (!fileExists(honoPath)) return {};

      isBuildCommand = env.command === 'build';

      // Validate peer dependencies when hono entry exists (skip during tests)
      if (process.env.NODE_ENV !== 'test') {
        const missingDeps = await checkPeerDependencies();
        if (missingDeps.length > 0) {
          throw new Error(
            `❌ Missing required peer dependencies: ${missingDeps.join(', ')}\n\n` +
            `Install them with:\n` +
            `  npm install ${missingDeps.join(' ')}\n` +
            `  # or\n` +
            `  pnpm add ${missingDeps.join(' ')}\n` +
            `  # or\n` +
            `  yarn add ${missingDeps.join(' ')}\n\n` +
            `These dependencies are required for the plugin to work properly.`
          );
        }
      }

      return {
        build: { outDir: 'dist/frontend', emptyOutDir: true },
        environments: {
          server: {
            build: {
              outDir: 'dist/',
              ssr: isBuildCommand ? `./${WRAPPER_FILE}` : HONO_ENTRY,
              copyPublicDir: false,
              emptyOutDir: false,
              rollupOptions: { output: { entryFileNames: 'server.js', format: 'esm' } },
            },
          },
        },
        builder: {
          async buildApp(builder) {
            await builder.build(builder.environments.client);
            if (builder.environments.server) await builder.build(builder.environments.server);
            copyDeployFiles('dist', workingDir);
          },
        },
      };
    },

    configResolved(config) {
      workingDir = config.root;
      const honoPath = join(workingDir, HONO_ENTRY);

      if (isBuildCommand && fileExists(honoPath)) {
        writeFileSync(join(workingDir, WRAPPER_FILE), generateWrapper(basePath, port), 'utf8');
        if (config.environments?.server?.build) {
          config.environments.server.build.ssr = `./${WRAPPER_FILE}`;
        }
      }
    },

    buildStart() {
      if (isBuildCommand && this.environment?.name === 'server') {
        const wrapperPath = join(workingDir, WRAPPER_FILE);
        if (!fileExists(wrapperPath)) {
          writeFileSync(wrapperPath, generateWrapper(basePath, port), 'utf8');
        }
      }
    },

    closeBundle: async () => {
      const wrapperPath = join(workingDir, WRAPPER_FILE);
      if (fileExists(wrapperPath)) {
        try {
          unlinkSync(wrapperPath);
        } catch { }
      }
    },

    configureServer(server) {
      const honoPath = join(workingDir, HONO_ENTRY);
      if (!fileExists(honoPath)) {
        server.config.logger.warn(
          `⚠️  ${HONO_ENTRY} not found. Hono API will not be available.\n` +
          `Create this file to enable the API:\n` +
          `  mkdir hono\n` +
          `  cat > hono/index.ts << 'EOF'\n` +
          `import { Hono } from 'hono';\n\n` +
          `const api = new Hono();\n` +
          `api.get('/', (c) => c.json({ message: 'Hello World' }));\n\n` +
          `export default api;\n` +
          `EOF`
        );
        return;
      }

      server.middlewares.use(async (req, res, next) => {
        if (!req.url || !req.method) return next();

        try {
          const url = new URL(req.url, `${req.headers['x-forwarded-proto'] || 'http'}://${req.headers.host || 'localhost:5173'}`);
          if (!url.pathname.startsWith(basePath)) return next();

          // Strip basePath to match production behavior
          const strippedUrl = new URL((url.pathname.slice(basePath.length) || '/') + url.search, url.origin);
          const app = await loadHonoApp(server);

          // Convert headers
          const headers = new Headers();
          for (const [key, value] of Object.entries(req.headers)) {
            if (typeof value === 'string') headers.set(key, value);
            else if (Array.isArray(value)) headers.set(key, value.join(', '));
          }

          // Create request and get response
          const request = new Request(strippedUrl.toString(), {
            method: req.method,
            headers,
            body: await readBody(req),
          });

          const response = await app.fetch(request);

          // Send response
          response.headers.forEach((value, key) => res.setHeader(key, value));
          res.writeHead(response.status);

          if (response.body) {
            const reader = response.body.getReader();
            try {
              while (true) {
                const { done, value } = await reader.read();
                if (done) break;
                res.write(value);
              }
            } finally {
              reader.releaseLock();
            }
          }
          res.end();
        } catch (error) {
          console.error('Hono middleware error:', error);
          res.writeHead(500, { 'Content-Type': 'application/json' });
          res.end(JSON.stringify({ error: 'Internal server error' }));
        }
      });
    },
  };
}
