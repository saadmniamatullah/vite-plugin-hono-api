import type { Plugin, ViteDevServer } from 'vite';
import {
  copyFileSync,
  mkdirSync,
  readFileSync,
  statSync,
  writeFileSync,
  unlinkSync,
} from 'node:fs';
import type { IncomingMessage, ServerResponse } from 'node:http';
import { join } from 'node:path';

type JsonRecord = Record<string, unknown>;
type NextFunction = (err?: unknown) => void;

const isJsonRecord = (value: unknown): value is JsonRecord =>
  typeof value === 'object' && value !== null && !Array.isArray(value);

const getString = (value: unknown): string | undefined =>
  typeof value === 'string' ? value : undefined;

const toHeaderValue = (value: string | readonly string[] | undefined): string | undefined => {
  if (typeof value === 'string') return value;
  if (Array.isArray(value)) {
    const parts: string[] = [];
    for (const entry of value) {
      if (typeof entry === 'string' && entry.length > 0) {
        parts.push(entry);
      }
    }
    return parts.length > 0 ? parts.join(', ') : undefined;
  }
  return undefined;
};

const toSingleHeaderValue = (value: string | readonly string[] | undefined): string | undefined => {
  if (typeof value === 'string') return value;
  if (Array.isArray(value)) {
    for (const entry of value) {
      if (typeof entry === 'string' && entry.length > 0) {
        return entry;
      }
    }
  }
  return undefined;
};

const readJsonFile = (path: string): unknown => JSON.parse(readFileSync(path, 'utf8'));

const isHonoApp = (value: unknown): value is HonoAppLike =>
  typeof value === 'object' &&
  value !== null &&
  typeof (value as { fetch?: unknown }).fetch === 'function';

const checkPeerDependencies = async () => {
  const missing: string[] = [];

  // Only Hono is required - runtime adapters are optional
  try {
    await import('hono');
  } catch {
    missing.push('hono');
  }

  return missing;
};

const checkViteVersion = () => {
  try {
    const vitePkg = readJsonFile('node_modules/vite/package.json');
    if (!isJsonRecord(vitePkg)) {
      return { valid: false, currentVersion: 'unknown', majorVersion: 0 };
    }

    const version = getString(vitePkg.version);
    if (!version) {
      return { valid: false, currentVersion: 'unknown', majorVersion: 0 };
    }

    const [majorPart] = version.split('.');
    const majorVersion = Number.parseInt(majorPart ?? '', 10);

    if (Number.isNaN(majorVersion) || majorVersion < 6) {
      return { valid: false, currentVersion: version, majorVersion };
    }

    return { valid: true, currentVersion: version, majorVersion };
  } catch {
    return { valid: false, currentVersion: 'unknown', majorVersion: 0 };
  }
};

export interface HonoPluginOptions {
  basePath?: string;
  port?: number;
}

interface HonoAppLike {
  fetch(request: Request): Response | Promise<Response>;
}

const HONO_ENTRY = 'hono/index.ts';
const WRAPPER_FILE = '.hono-server.mjs';

const fileExists = (path: string) => {
  try {
    return statSync(path).isFile();
  } catch {
    return false;
  }
};

const generateWrapper = (basePath: string, port: number) =>
  `// Auto-generated by vite-plugin-hono (multi-runtime)
import { Hono } from 'hono';
import api from './hono/index';

const app = new Hono();
app.route('${basePath}', api);

// Runtime detection and initialization
const isDeno = typeof Deno !== 'undefined';
const isBun = typeof Bun !== 'undefined';

if (isDeno) {
  // Deno: Use Deno.serve with static file handling
  const { serveStatic } = await import('npm:@hono/deno@^1.0.0');
  app.use('*', serveStatic({ root: './frontend' }));
  app.get('*', serveStatic({ root: './frontend', path: 'index.html' }));
  
  const serverPort = Number(Deno.env.get('PORT') ?? ${port});
  Deno.serve({ port: serverPort }, app.fetch);
  console.log(\`Server running on http://localhost:\${serverPort} (Deno)\`);
  
} else if (isBun) {
  // Bun: Use Bun.serve and hono/bun static
  const { serveStatic } = await import('hono/bun');
  app.use('*', serveStatic({ root: './frontend' }));
  app.get('*', serveStatic({ root: './frontend', path: 'index.html' }));
  
  const serverPort = Number(process.env.PORT ?? ${port});
  export default {
    port: serverPort,
    fetch: app.fetch,
  };
  console.log(\`Server running on http://localhost:\${serverPort} (Bun)\`);
  
} else {
  // Node.js: Use @hono/node-server
  const { serve } = await import('@hono/node-server');
  const { serveStatic } = await import('@hono/node-server/serve-static');
  app.use('*', serveStatic({ root: './frontend' }));
  app.get('*', serveStatic({ root: './frontend', path: 'index.html' }));
  
  const serverPort = Number(process.env.PORT ?? ${port});
  serve({ fetch: app.fetch, port: serverPort });
  console.log(\`Server running on http://localhost:\${serverPort} (Node.js)\`);
}

export default app;`;

const copyDeployFiles = (targetDir: string, workingDir: string) => {
  mkdirSync(targetDir, { recursive: true });

  for (const file of [
    'package.json',
    'package-lock.json',
    'pnpm-lock.yaml',
    'yarn.lock',
    'bun.lockb',
  ]) {
    const path = join(workingDir, file);
    if (!fileExists(path)) continue;

    if (file === 'package.json') {
      const pkgRaw = readJsonFile(path);
      if (!isJsonRecord(pkgRaw)) {
        throw new Error(`Invalid package.json structure at ${path}`);
      }

      const pkgWithScripts: JsonRecord = {
        ...pkgRaw,
        scripts: { start: 'node server.js' },
      };

      writeFileSync(join(targetDir, file), JSON.stringify(pkgWithScripts, null, 2) + '\n', 'utf8');
    } else {
      copyFileSync(path, join(targetDir, file));
    }
  }
};

const loadHonoApp = async (server: ViteDevServer): Promise<HonoAppLike> => {
  const url = `/${HONO_ENTRY}`;
  const moduleNode = await server.moduleGraph.getModuleByUrl(url, true);
  if (moduleNode) {
    server.moduleGraph.invalidateModule(moduleNode);
  }

  const loadedModule = await server.ssrLoadModule(url);
  const app = (loadedModule as { default?: unknown }).default;
  if (!isHonoApp(app)) {
    throw new Error(`${HONO_ENTRY} must export a Hono app with fetch()`);
  }
  return app;
};

const readBody = (req: IncomingMessage): Promise<BodyInit | undefined> =>
  new Promise((resolve, reject) => {
    if (req.method === 'GET' || req.method === 'HEAD') return resolve(undefined);
    const chunks: Buffer[] = [];
    req.on('data', (chunk: Buffer) => chunks.push(chunk));
    req.on('end', () => {
      if (chunks.length === 0) {
        resolve(undefined);
        return;
      }
      const body = Buffer.concat(chunks);
      resolve(body as unknown as BodyInit);
    });
    req.on('error', reject);
  });

export default function honoPlugin(options: HonoPluginOptions = {}): Plugin {
  const { basePath = '/api', port = 4173 } = options;
  let workingDir = process.cwd();
  let isBuildCommand = false;

  // Validate Vite version
  const viteCheck = checkViteVersion();
  if (!viteCheck.valid) {
    throw new Error(
      `❌ vite-plugin-hono-api requires Vite 6+. Current version: ${viteCheck.currentVersion}\n` +
        `To upgrade: npm install vite@latest\n` +
        `Or check your package.json for version constraints.`
    );
  }

  return {
    name: 'vite-plugin-hono',

    // Vite 7 Environment API support
    perEnvironmentStartEndDuringDev: true,
    sharedDuringBuild: true,

    // Apply to server environment only
    applyToEnvironment(environment) {
      // Only apply to server/ssr environments, not client
      return environment.name === 'server' || environment.name === 'ssr';
    },

    config: async (_config, env) => {
      workingDir = _config?.root || process.cwd();
      const honoPath = join(workingDir, HONO_ENTRY);
      if (!fileExists(honoPath)) return {};

      isBuildCommand = env.command === 'build';

      // Validate peer dependencies when hono entry exists (skip during tests)
      if (process.env.NODE_ENV !== 'test') {
        const missingDeps = await checkPeerDependencies();
        if (missingDeps.length > 0) {
          throw new Error(
            `❌ Missing required peer dependency: ${missingDeps.join(', ')}\n\n` +
              `Install it with:\n` +
              `  npm install ${missingDeps.join(' ')}\n` +
              `  # or\n` +
              `  pnpm add ${missingDeps.join(' ')}\n` +
              `  # or\n` +
              `  bun add ${missingDeps.join(' ')}\n\n` +
              `Note: For Node.js runtime, you'll also need: @hono/node-server @types/node`
          );
        }
      }

      return {
        build: { outDir: 'dist/frontend', emptyOutDir: true },
        environments: {
          server: {
            build: {
              outDir: 'dist/',
              ssr: isBuildCommand ? `./${WRAPPER_FILE}` : HONO_ENTRY,
              copyPublicDir: false,
              emptyOutDir: false,
              rollupOptions: { output: { entryFileNames: 'server.js', format: 'esm' } },
            },
          },
        },
        builder: {
          async buildApp(builder) {
            await builder.build(builder.environments.client);
            if (builder.environments.server) await builder.build(builder.environments.server);
            copyDeployFiles('dist', workingDir);
          },
        },
      };
    },

    configResolved(config) {
      workingDir = config.root;
      const honoPath = join(workingDir, HONO_ENTRY);

      if (isBuildCommand && fileExists(honoPath)) {
        writeFileSync(join(workingDir, WRAPPER_FILE), generateWrapper(basePath, port), 'utf8');
        if (config.environments?.server?.build) {
          config.environments.server.build.ssr = `./${WRAPPER_FILE}`;
        }
      }
    },

    buildStart() {
      // Use environment context to determine if this is the server build
      const isServerEnv = this.environment?.name === 'server' || this.environment?.name === 'ssr';
      
      if (isBuildCommand && isServerEnv) {
        const wrapperPath = join(workingDir, WRAPPER_FILE);
        if (!fileExists(wrapperPath)) {
          writeFileSync(wrapperPath, generateWrapper(basePath, port), 'utf8');
        }
      }
    },

    closeBundle() {
      const wrapperPath = join(workingDir, WRAPPER_FILE);
      if (fileExists(wrapperPath)) {
        try {
          unlinkSync(wrapperPath);
        } catch (error) {
          console.warn('Failed to remove generated Hono wrapper file:', error);
        }
      }
    },

    configureServer(server) {
      const honoPath = join(workingDir, HONO_ENTRY);
      if (!fileExists(honoPath)) {
        server.config.logger.warn(
          `⚠️  ${HONO_ENTRY} not found. Hono API will not be available.\n` +
            `Create this file to enable the API:\n` +
            `  mkdir hono\n` +
            `  cat > hono/index.ts << 'EOF'\n` +
            `import { Hono } from 'hono';\n\n` +
            `const api = new Hono();\n` +
            `api.get('/', (c) => c.json({ message: 'Hello World' }));\n\n` +
            `export default api;\n` +
            `EOF`
        );
        return;
      }

      const handleRequest = async (
        req: IncomingMessage,
        res: ServerResponse,
        next: NextFunction
      ) => {
        if (!req.url || !req.method) {
          next();
          return;
        }

        const protocol = toSingleHeaderValue(req.headers['x-forwarded-proto']) ?? 'http';
        const host = toSingleHeaderValue(req.headers.host) ?? 'localhost:5173';
        const url = new URL(req.url, `${protocol}://${host}`);
        if (!url.pathname.startsWith(basePath)) {
          next();
          return;
        }

        try {
          const strippedPath = url.pathname.slice(basePath.length) || '/';
          const strippedUrl = new URL(strippedPath + url.search, url.origin);
          const app = await loadHonoApp(server);

          const headers = new Headers();
          for (const [key, value] of Object.entries(req.headers)) {
            const normalizedValue = toHeaderValue(value);
            if (normalizedValue) {
              headers.set(key, normalizedValue);
            }
          }

          const request = new Request(strippedUrl.toString(), {
            method: req.method,
            headers,
            body: await readBody(req),
          });

          const response = await app.fetch(request);

          response.headers.forEach((value, key) => res.setHeader(key, value));
          res.writeHead(response.status);

          if (response.body) {
            const reader = response.body.getReader();
            try {
              while (true) {
                const { done, value } = await reader.read();
                if (done) break;
                res.write(value);
              }
            } finally {
              reader.releaseLock();
            }
          }

          res.end();
        } catch (error) {
          console.error('Hono middleware error:', error);
          res.writeHead(500, { 'Content-Type': 'application/json' });
          res.end(JSON.stringify({ error: 'Internal server error' }));
        }
      };

      server.middlewares.use((req: IncomingMessage, res: ServerResponse, next: NextFunction) => {
        void handleRequest(req, res, next);
      });
    },
  };
}
